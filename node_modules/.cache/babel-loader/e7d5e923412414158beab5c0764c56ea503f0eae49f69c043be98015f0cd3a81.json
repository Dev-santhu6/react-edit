{"ast":null,"code":"/*!\r\n * purecounter.js - A simple yet configurable native javascript counter which you can count on.\r\n * Author: Stig Rex\r\n * Version: 1.5.0\r\n * Url: https://github.com/srexi/purecounterjs\r\n * License: MIT\r\n */\n!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.PureCounter = t() : e.PureCounter = t();\n}(self, function () {\n  return e = {\n    638: function (e) {\n      function t(e, t, r) {\n        return t in e ? Object.defineProperty(e, t, {\n          value: r,\n          enumerable: !0,\n          configurable: !0,\n          writable: !0\n        }) : e[t] = r, e;\n      }\n      function r(e) {\n        return function (e) {\n          if (Array.isArray(e)) return n(e);\n        }(e) || function (e) {\n          if (\"undefined\" != typeof Symbol && null != e[Symbol.iterator] || null != e[\"@@iterator\"]) return Array.from(e);\n        }(e) || function (e, t) {\n          if (e) {\n            if (\"string\" == typeof e) return n(e, t);\n            var r = Object.prototype.toString.call(e).slice(8, -1);\n            return \"Object\" === r && e.constructor && (r = e.constructor.name), \"Map\" === r || \"Set\" === r ? Array.from(e) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? n(e, t) : void 0;\n          }\n        }(e) || function () {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n        }();\n      }\n      function n(e, t) {\n        (null == t || t > e.length) && (t = e.length);\n        for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];\n        return n;\n      }\n      function o(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n          r = {};\n        for (var n in e) if (t == {} || t.hasOwnProperty(n)) {\n          var o = c(e[n]);\n          r[n] = o, n.match(/duration|pulse/) && (r[n] = \"boolean\" != typeof o ? 1e3 * o : o);\n        }\n        return Object.assign({}, t, r);\n      }\n      function i(e, t) {\n        var r = (t.end - t.start) / (t.duration / t.delay),\n          n = \"inc\";\n        t.start > t.end && (n = \"dec\", r *= -1);\n        var o = c(t.start);\n        e.innerHTML = u(o, t), !0 === t.once && e.setAttribute(\"data-purecounter-duration\", 0);\n        var i = setInterval(function () {\n          var a = function (e, t) {\n            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : \"inc\";\n            return e = c(e), t = c(t), parseFloat(\"inc\" === r ? e + t : e - t);\n          }(o, r, n);\n          e.innerHTML = u(a, t), ((o = a) >= t.end && \"inc\" == n || o <= t.end && \"dec\" == n) && (e.innerHTML = u(t.end, t), t.pulse && (e.setAttribute(\"data-purecounter-duration\", 0), setTimeout(function () {\n            e.setAttribute(\"data-purecounter-duration\", t.duration / 1e3);\n          }, t.pulse)), clearInterval(i));\n        }, t.delay);\n      }\n      function a(e, t) {\n        return Math.pow(e, t);\n      }\n      function u(e, t) {\n        var r = {\n            minimumFractionDigits: t.decimals,\n            maximumFractionDigits: t.decimals\n          },\n          n = \"string\" == typeof t.formater ? t.formater : void 0;\n        return e = function (e, t) {\n          if (t.filesizing || t.currency) {\n            e = Math.abs(Number(e));\n            var r = 1e3,\n              n = t.currency && \"string\" == typeof t.currency ? t.currency : \"\",\n              o = t.decimals || 1,\n              i = [\"\", \"K\", \"M\", \"B\", \"T\"],\n              u = \"\";\n            t.filesizing && (r = 1024, i = [\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"]);\n            for (var c = 4; c >= 0; c--) if (0 === c && (u = \"\".concat(e.toFixed(o), \" \").concat(i[c])), e >= a(r, c)) {\n              u = \"\".concat((e / a(r, c)).toFixed(o), \" \").concat(i[c]);\n              break;\n            }\n            return n + u;\n          }\n          return parseFloat(e);\n        }(e, t), function (e, t) {\n          if (t.formater) {\n            var r = t.separator ? \"string\" == typeof t.separator ? t.separator : \",\" : \"\";\n            return \"en-US\" !== t.formater && !0 === t.separator ? e : (n = r, e.replace(/^(?:(\\d{1,3},(?:\\d{1,3},?)*)|(\\d{1,3}\\.(?:\\d{1,3}\\.?)*)|(\\d{1,3}(?:\\s\\d{1,3})*))([\\.,]?\\d{0,2}?)$/gi, function (e, t, r, o, i) {\n              var a = \"\",\n                u = \"\";\n              if (void 0 !== t ? (a = t.replace(new RegExp(/,/gi, \"gi\"), n), u = \",\") : void 0 !== r ? a = r.replace(new RegExp(/\\./gi, \"gi\"), n) : void 0 !== o && (a = o.replace(new RegExp(/ /gi, \"gi\"), n)), void 0 !== i) {\n                var c = \",\" !== u && \",\" !== n ? \",\" : \".\";\n                a += void 0 !== i ? i.replace(new RegExp(/\\.|,/gi, \"gi\"), c) : \"\";\n              }\n              return a;\n            }));\n          }\n          var n;\n          return e;\n        }(e = t.formater ? e.toLocaleString(n, r) : parseInt(e).toString(), t);\n      }\n      function c(e) {\n        return /^[0-9]+\\.[0-9]+$/.test(e) ? parseFloat(e) : /^[0-9]+$/.test(e) ? parseInt(e) : /^true|false/i.test(e) ? /^true/i.test(e) : e;\n      }\n      function f(e) {\n        for (var t = e.offsetTop, r = e.offsetLeft, n = e.offsetWidth, o = e.offsetHeight; e.offsetParent;) t += (e = e.offsetParent).offsetTop, r += e.offsetLeft;\n        return t >= window.pageYOffset && r >= window.pageXOffset && t + o <= window.pageYOffset + window.innerHeight && r + n <= window.pageXOffset + window.innerWidth;\n      }\n      function s() {\n        return \"IntersectionObserver\" in window && \"IntersectionObserverEntry\" in window && \"intersectionRatio\" in window.IntersectionObserverEntry.prototype;\n      }\n      e.exports = function () {\n        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n          n = {\n            start: 0,\n            end: 100,\n            duration: 2e3,\n            delay: 10,\n            once: !0,\n            pulse: !1,\n            decimals: 0,\n            legacy: !0,\n            filesizing: !1,\n            currency: !1,\n            separator: !1,\n            formater: \"us-US\",\n            selector: \".purecounter\"\n          },\n          a = o(e, n);\n        function d() {\n          var e = document.querySelectorAll(a.selector);\n          if (0 !== e.length) if (s()) {\n            var t = new IntersectionObserver(p.bind(this), {\n              root: null,\n              rootMargin: \"20px\",\n              threshold: .5\n            });\n            e.forEach(function (e) {\n              t.observe(e);\n            });\n          } else window.addEventListener && (l(e), window.addEventListener(\"scroll\", function (t) {\n            l(e);\n          }, {\n            passive: !0\n          }));\n        }\n        function l(e) {\n          e.forEach(function (e) {\n            !0 === v(e).legacy && f(e) && p([e]);\n          });\n        }\n        function p(e, t) {\n          e.forEach(function (e) {\n            var r = e.target || e,\n              n = v(r);\n            if (n.duration <= 0) return r.innerHTML = u(n.end, n);\n            if (!t && !f(e) || t && e.intersectionRatio < .5) {\n              var o = n.start > n.end ? n.end : n.start;\n              return r.innerHTML = u(o, n);\n            }\n            setTimeout(function () {\n              return i(r, n);\n            }, n.delay);\n          });\n        }\n        function v(e) {\n          var n = a,\n            i = [].filter.call(e.attributes, function (e) {\n              return /^data-purecounter-/.test(e.name);\n            });\n          return o(0 != i.length ? Object.assign.apply(Object, [{}].concat(r(i.map(function (e) {\n            var r = e.name,\n              n = e.value;\n            return t({}, r.replace(\"data-purecounter-\", \"\").toLowerCase(), c(n));\n          })))) : {}, n);\n        }\n        d();\n      };\n    }\n  }, t = {}, r = function r(n) {\n    var o = t[n];\n    if (void 0 !== o) return o.exports;\n    var i = t[n] = {\n      exports: {}\n    };\n    return e[n](i, i.exports, r), i.exports;\n  }(638), r;\n  var e, t, r;\n});","map":{"version":3,"names":["e","t","exports","module","define","amd","PureCounter","self","o","arguments","length","r","n","hasOwnProperty","c","match","Object","assign","i","end","start","duration","delay","innerHTML","u","once","setAttribute","setInterval","a","parseFloat","pulse","setTimeout","clearInterval","Math","pow","minimumFractionDigits","decimals","maximumFractionDigits","formater","filesizing","currency","abs","Number","concat","toFixed","separator","replace","RegExp","toLocaleString","parseInt","toString","test","f","offsetTop","offsetLeft","offsetWidth","offsetHeight","offsetParent","window","pageYOffset","pageXOffset","innerHeight","innerWidth","s","IntersectionObserverEntry","prototype","legacy","selector","d","document","querySelectorAll","IntersectionObserver","p","bind","root","rootMargin","threshold","forEach","observe","addEventListener","l","passive","v","target","intersectionRatio","filter","call","attributes","name","apply","map","value","toLowerCase"],"sources":["webpack://PureCounter/webpack/universalModuleDefinition","webpack://PureCounter/js/purecounter_vanilla.js","webpack://PureCounter/webpack/bootstrap","webpack://PureCounter/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PureCounter\"] = factory();\n\telse\n\t\troot[\"PureCounter\"] = factory();\n})(self, function() {\nreturn ","/** This function is for create and merge configuration */\r\nfunction setOptions(config, baseConfig = {}) {\r\n    // Create new Config object;\r\n    var newConfig = {};\r\n\r\n    // Loop config items to set it value into newConfig\r\n    for (var key in config) {\r\n        // if baseConfig is set, only accept the baseconfig property\r\n        if (baseConfig != {} && !baseConfig.hasOwnProperty(key)) continue;\r\n        // parse the config value\r\n        var val = parseValue(config[key]);\r\n        // set the newConfig property value\r\n        newConfig[key] = val;\r\n        // Exclusive for 'duration' or 'pulse' property, recheck the value\r\n        // If it's not a boolean, just set it to milisecond unit\r\n        if (key.match(/duration|pulse/)) {\r\n            newConfig[key] = typeof val != \"boolean\" ? val * 1000 : val;\r\n        }\r\n    }\r\n\r\n    // Finally, we can just merge the baseConfig (if any), with newConfig.\r\n    return Object.assign({}, baseConfig, newConfig);\r\n}\r\n\r\n/** This is the the counter method */\r\nfunction startCounter(element, config) {\r\n    // First, get the increments step\r\n    var incrementsPerStep =\r\n        (config.end - config.start) / (config.duration / config.delay);\r\n    // Next, set the counter mode (Increment or Decrement)\r\n    var countMode = \"inc\";\r\n\r\n    // Set mode to 'decrement' and 'increment step' to minus if start is larger than end\r\n    if (config.start > config.end) {\r\n        countMode = \"dec\";\r\n        incrementsPerStep *= -1;\r\n    }\r\n\r\n    // Next, determine the starting value\r\n    var currentCount = parseValue(config.start);\r\n    // And then print it's value to the page\r\n    element.innerHTML = formatNumber(currentCount, config);\r\n\r\n    // If the config 'once' is true, then set the 'duration' to 0\r\n    if (config.once === true) {\r\n        element.setAttribute(\"data-purecounter-duration\", 0);\r\n    }\r\n\r\n    // Now, start counting with counterWorker using Interval method based on delay\r\n    var counterWorker = setInterval(() => {\r\n        // First, determine the next value base on current value, increment value, and count mode\r\n        var nextNum = nextNumber(currentCount, incrementsPerStep, countMode);\r\n        // Next, print that value to the page\r\n        element.innerHTML = formatNumber(nextNum, config);\r\n        // Now set that value to the current value, because it's already printed\r\n        currentCount = nextNum;\r\n\r\n        // If the value is larger or less than the 'end' (base on mode), then  print the end value and stop the Interval\r\n        if (\r\n            (currentCount >= config.end && countMode == \"inc\") ||\r\n            (currentCount <= config.end && countMode == \"dec\")\r\n        ) {\r\n            element.innerHTML = formatNumber(config.end, config);\r\n            // If 'pulse' is set ignore the 'once' config\r\n            if (config.pulse) {\r\n                // First set the 'duration' to zero\r\n                element.setAttribute(\"data-purecounter-duration\", 0);\r\n                // Next, use timeout to reset it duration back based on 'pulse' config\r\n                setTimeout(() => {\r\n                    element.setAttribute(\r\n                        \"data-purecounter-duration\",\r\n                        config.duration / 1000\r\n                    );\r\n                }, config.pulse);\r\n            }\r\n            clearInterval(counterWorker);\r\n        }\r\n    }, config.delay);\r\n}\r\n\r\n/** This function is to get the next number */\r\nfunction nextNumber(number, steps, mode = \"inc\") {\r\n    // First, get the exact value from the number and step (int or float)\r\n    number = parseValue(number);\r\n    steps = parseValue(steps);\r\n\r\n    // Last, get the next number based on current number, increment step, and count mode\r\n    // Always return it as float\r\n    return parseFloat(mode === \"inc\" ? number + steps : number - steps);\r\n}\r\n\r\n/** This function is to convert number into currency format */\r\nfunction convertNumber(number, config) {\r\n    /** Use converter if filesizing or currency is on */\r\n    if (config.filesizing || config.currency) {\r\n        number = Math.abs(Number(number)); // Get the absolute value of number\r\n\r\n        var baseNumber = 1000, // Base multiplying treshold\r\n            symbol =\r\n                config.currency && typeof config.currency === \"string\"\r\n                    ? config.currency\r\n                    : \"\", // Set the Currency Symbol (if any)\r\n            limit = config.decimals || 1, // Set the decimal limit (default is 1)\r\n            unit = [\"\", \"K\", \"M\", \"B\", \"T\"], // Number unit based exponent threshold\r\n            value = \"\"; // Define value variable\r\n\r\n        /** Changes base number and its unit for filesizing */\r\n        if (config.filesizing) {\r\n            baseNumber = 1024; // Use 1024 instead of 1000\r\n            unit = [\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"]; // Change to 'bytes' unit\r\n        }\r\n\r\n        /** Set value based on the threshold */\r\n        for (var i = 4; i >= 0; i--) {\r\n            // If the exponent is 0\r\n            if (i === 0) value = `${number.toFixed(limit)} ${unit[i]}`;\r\n            // If the exponent is above zero\r\n            if (number >= getFilesizeThreshold(baseNumber, i)) {\r\n                value = `${(number / getFilesizeThreshold(baseNumber, i)).toFixed(\r\n                    limit\r\n                )} ${unit[i]}`;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Apply symbol before the value and return it as string\r\n        return symbol + value;\r\n    } else {\r\n        /** Return its value as float if not using filesizing or currency*/\r\n        return parseFloat(number);\r\n    }\r\n}\r\n\r\n/** This function will get the given base.  */\r\nfunction getFilesizeThreshold(baseNumber, index) {\r\n    return Math.pow(baseNumber, index);\r\n}\r\n\r\n/** This function is to get the last formated number */\r\nfunction applySeparator(value, config) {\r\n    // Get replaced value based on it's separator/symbol.\r\n    function replacedValue(val, separator) {\r\n        // Well this is my regExp for detecting the Thausands Separator\r\n        // I use 3 groups to determine it's separator\r\n        // THen the group 4 is to get the decimals value\r\n        var separatorRegExp =\r\n            /^(?:(\\d{1,3},(?:\\d{1,3},?)*)|(\\d{1,3}\\.(?:\\d{1,3}\\.?)*)|(\\d{1,3}(?:\\s\\d{1,3})*))([\\.,]?\\d{0,2}?)$/gi;\r\n\r\n        return val.replace(separatorRegExp, function (match, g1, g2, g3, g4) {\r\n            // set initial result value\r\n            var result = \"\",\r\n                sep = \"\";\r\n            if (g1 !== undefined) {\r\n                // Group 1 is using comma as thausands separator, and period as decimal separator\r\n                result = g1.replace(new RegExp(/,/gi, \"gi\"), separator);\r\n                sep = \",\";\r\n            } else if (g2 !== undefined) {\r\n                // Group 2 is using period as thausands separator, and comma as decimal separator\r\n                result = g2.replace(new RegExp(/\\./gi, \"gi\"), separator);\r\n            } else if (g3 !== undefined) {\r\n                // Group 3 is using space as thausands separator, and comma as decimal separator\r\n                result = g3.replace(new RegExp(/ /gi, \"gi\"), separator);\r\n            }\r\n            if (g4 !== undefined) {\r\n                var decimal = sep !== \",\" ? (separator !== \",\" ? \",\" : \".\") : \".\";\r\n                result +=\r\n                    g4 !== undefined\r\n                        ? g4.replace(new RegExp(/\\.|,/gi, \"gi\"), decimal)\r\n                        : \"\";\r\n            }\r\n            // Returning result value;\r\n            return result;\r\n        });\r\n    }\r\n    // If config formater is not false, then apply separator\r\n    if (config.formater) {\r\n        // Now get the separator symbol\r\n        var symbol = config.separator // if config separator is setted\r\n            ? typeof config.separator === \"string\" // Check the type of value\r\n                ? config.separator // If it's type is string, then apply it's value\r\n                : \",\" // If it's not string (boolean), then apply comma as default separator\r\n            : \"\";\r\n        // Special exception when locale is not 'en-US' but separator value is 'true'\r\n        // Use it's default locale thausands separator.\r\n        if (config.formater !== \"en-US\" && config.separator === true) {\r\n            return value;\r\n        }\r\n        // Return the replaced Value based on it's symbol\r\n        return replacedValue(value, symbol);\r\n    }\r\n    // If config formater is false, then return it's default value\r\n    return value;\r\n}\r\n\r\n/** This function is to get formated number to be printed in the page */\r\nfunction formatNumber(number, config) {\r\n    // This is the configuration for 'toLocaleString' method\r\n    var strConfig = {\r\n        minimumFractionDigits: config.decimals,\r\n        maximumFractionDigits: config.decimals,\r\n    };\r\n    // Get locale from config formater\r\n    var locale = typeof config.formater === \"string\" ? config.formater : undefined;\r\n\r\n    // Set and convert the number base on its config.\r\n    number = convertNumber(number, config);\r\n\r\n    // Now format the number to string base on it's locale\r\n    number = config.formater\r\n        ? number.toLocaleString(locale, strConfig)\r\n        : parseInt(number).toString();\r\n\r\n    // Last, apply the number separator using number as string\r\n    return applySeparator(number, config);\r\n}\r\n\r\n/** This function is to get the parsed value */\r\nfunction parseValue(data) {\r\n    // If number with dot (.), will be parsed as float\r\n    if (/^[0-9]+\\.[0-9]+$/.test(data)) {\r\n        return parseFloat(data);\r\n    }\r\n    // If just number, will be parsed as integer\r\n    if (/^[0-9]+$/.test(data)) {\r\n        return parseInt(data);\r\n    }\r\n    // If it's boolean string, will be parsed as boolean\r\n    if (/^true|false/i.test(data)) {\r\n        return /^true/i.test(data);\r\n    }\r\n    // Return it's value as default\r\n    return data;\r\n}\r\n\r\n// This function is to detect the element is in view or not.\r\nfunction elementIsInView(element) {\r\n    var top = element.offsetTop;\r\n    var left = element.offsetLeft;\r\n    var width = element.offsetWidth;\r\n    var height = element.offsetHeight;\r\n\r\n    while (element.offsetParent) {\r\n        element = element.offsetParent;\r\n        top += element.offsetTop;\r\n        left += element.offsetLeft;\r\n    }\r\n\r\n    return (\r\n        top >= window.pageYOffset &&\r\n        left >= window.pageXOffset &&\r\n        top + height <= window.pageYOffset + window.innerHeight &&\r\n        left + width <= window.pageXOffset + window.innerWidth\r\n    );\r\n}\r\n\r\n/** Just some condition to check browser Intersection Support */\r\nfunction intersectionListenerSupported() {\r\n    return (\r\n        \"IntersectionObserver\" in window &&\r\n        \"IntersectionObserverEntry\" in window &&\r\n        \"intersectionRatio\" in window.IntersectionObserverEntry.prototype\r\n    );\r\n}\r\n\r\n/** Initialize PureCounter */\r\nfunction PureCounter(options = {}) {\r\n    var configs = {\r\n        start: 0, // Starting number [uint]\r\n        end: 100, // End number [uint]\r\n        duration: 2000, // Count duration [milisecond]\r\n        delay: 10, // Count delay [milisecond]\r\n        once: true, // Counting at once or recount when scroll [boolean]\r\n        pulse: false, // Pulse count for certain time [boolean|milisecond]\r\n        decimals: 0, // Decimal places [uint]\r\n        legacy: true, // If this is true it will use the scroll event listener on browsers\r\n        filesizing: false, // Is it for filesize?\r\n        currency: false, // Is it for currency? Use it for set the symbol too [boolean|char|string]\r\n        separator: false, // Do you want to use thausands separator? use it for set the symbol too [boolean|char|string]\r\n        formater: \"us-US\", // Number toLocaleString locale/formater, by default is \"en-US\" [string|boolean:false]\r\n        selector: \".purecounter\", // HTML query selector for spesific element\r\n    };\r\n    var configOptions = setOptions(options, configs);\r\n\r\n    function registerEventListeners() {\r\n        /** Get all elements with class 'purecounter' */\r\n        var elements = document.querySelectorAll(configOptions.selector);\r\n        /** Return if no elements */\r\n        if (elements.length === 0) {\r\n            return;\r\n        }\r\n\r\n        /** Run animateElements base on Intersection Support */\r\n        if (intersectionListenerSupported()) {\r\n            var intersectObserver = new IntersectionObserver(animateElements.bind(this), {\r\n                root: null,\r\n                rootMargin: \"20px\",\r\n                threshold: 0.5,\r\n            });\r\n\r\n            elements.forEach((element) => {\r\n                intersectObserver.observe(element);\r\n            });\r\n        } else {\r\n            if (window.addEventListener) {\r\n                animateLegacy(elements);\r\n                window.addEventListener(\r\n                    \"scroll\",\r\n                    function (e) {\r\n                        animateLegacy(elements);\r\n                    },\r\n                    { passive: true }\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /** This legacy to make Purecounter use very lightweight & fast */\r\n    function animateLegacy(elements) {\r\n        elements.forEach((element) => {\r\n            var config = parseConfig(element);\r\n            if (config.legacy === true && elementIsInView(element)) {\r\n                animateElements([element]);\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Main Element Count Animation */\r\n    function animateElements(elements, observer) {\r\n        elements.forEach((element) => {\r\n            var elm = element.target || element; // Just make sure which element will be used\r\n            var elementConfig = parseConfig(elm); // Get config value on that element\r\n\r\n            // If duration is less than or equal zero, just format the 'end' value\r\n            if (elementConfig.duration <= 0) {\r\n                return (elm.innerHTML = formatNumber(elementConfig.end, elementConfig));\r\n            }\r\n\r\n            if (\r\n                (!observer && !elementIsInView(element)) ||\r\n                (observer && element.intersectionRatio < 0.5)\r\n            ) {\r\n                var value =\r\n                    elementConfig.start > elementConfig.end\r\n                        ? elementConfig.end\r\n                        : elementConfig.start;\r\n                return (elm.innerHTML = formatNumber(value, elementConfig));\r\n            }\r\n\r\n            // If duration is more than 0, then start the counter\r\n            setTimeout(() => {\r\n                return startCounter(elm, elementConfig);\r\n            }, elementConfig.delay);\r\n        });\r\n    }\r\n\r\n    /** This function is to generate the element Config */\r\n    function parseConfig(element) {\r\n        // First, we need to declare the base Config\r\n        // This config will be used if the element doesn't have config\r\n        var baseConfig = configOptions;\r\n\r\n        // Next, get all 'data-precounter-*' attributes value. Store to array\r\n        var configValues = [].filter.call(element.attributes, function (attr) {\r\n            return /^data-purecounter-/.test(attr.name);\r\n        });\r\n\r\n        // Now, we create element config as an object\r\n        var elementConfig =\r\n            configValues.length != 0\r\n                ? Object.assign(\r\n                      {},\r\n                      ...configValues.map(({ name, value }) => {\r\n                          var key = name.replace(\"data-purecounter-\", \"\").toLowerCase(),\r\n                              val = parseValue(value);\r\n\r\n                          return { [key]: val };\r\n                      })\r\n                  )\r\n                : {};\r\n\r\n        // Last setOptions and return\r\n        return setOptions(elementConfig, baseConfig);\r\n    }\r\n\r\n    /** Run the initial function */\r\n    registerEventListeners();\r\n}\r\n\r\nmodule.exports = PureCounter;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(638);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}